package com.dropbox.kaiken.processor

import com.dropbox.kaiken.annotation.DaggerInjectable
import com.dropbox.kaiken.annotation.Injectable
import com.dropbox.kaiken.processor.internal.GENERATED_BY_TOP_COMMENT
import com.squareup.anvil.annotations.MergeComponent
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import javax.annotation.processing.Filer
import javax.lang.model.element.Element
import javax.lang.model.element.TypeElement
import javax.lang.model.type.MirroredTypeException
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import kotlin.reflect.KClass

/**
 * Generates a `Injector` interface definition and an `inject` function for the given annotated
 * activity.
 *
 * Example:
 *
 * ```
 * @InjectableActivity
 * public class MyActivity : AppCompatActivity() {
 *     ...
 * }
 * ```
 *
 * will generate:
 *
 * ```
 * interface MyActivityInjector {
 *    void inject(activity: MyActivity)
 * }
 *
 * fun MyActivity.inject() {
 *     val injector: MyActivityInjector = this.locateInjector()
 *     injector.inject(this)
 * }
 * ```
 *
 * Note that the interface definition is written in Java this is because of an issue with Dagger
 * (https://github.com/google/dagger/issues/665). Dagger is not auto-generating code for
 * autogenerated interfaces written in Kotlin, so leave the interface definition in Java for now.
 */
internal class InjectableActivityWriter(
    private val filer: Filer,
    private val elementUtils: Elements
) {
    fun write(
        annotatedActivity: InjectableAnnotatedActivity,
        elements: Elements
    ) {
        val annotatedActivityTypeElement = annotatedActivity.annotatedActivityElement
        val canInjectActivityInterfaceName = resolveInterfaceName(annotatedActivity)
        val pack = elementUtils.getPackageOf(annotatedActivityTypeElement).toString()
        val annotatedActivityType = annotatedActivityTypeElement.asType()

        var injectableAnnotationComponent = injectableAnnotation(annotatedActivityTypeElement)
        val scope: TypeMirror?
        var anvilScope: ClassName? = null
        val dependencyClassname = daggerInjectableAnnotation(annotatedActivityTypeElement)

        //if user component is an anvil component we should grab the scope
        if (injectableAnnotationComponent != null && anvilOnPath()) {
            scope = componentAnvilScope(elements, injectableAnnotationComponent)
            anvilScope = scope?.asTypeName() as ClassName
        }
        if (anvilOnPath() && anvilScope == null) {
            val activityTypeName = annotatedActivityType.asTypeName() as ClassName
            anvilScope = activityTypeName.peerClass("A${activityTypeName.simpleName}Scope")
        }

        if (dependencyClassname != null) {
            generateComponent(pack, annotatedActivityType, dependencyClassname)
            val className = annotatedActivityType.asTypeName() as ClassName
            //we made a component and want to pass that to other generators
            injectableAnnotationComponent =
                className.peerClass(className.simpleName + "Component")
        }

        // elements.
        writeInterfaceFile(
            pack,
            canInjectActivityInterfaceName,
            annotatedActivityType,
            anvilScope
        )



        writeExtensionFunctionFile(
            pack,
            canInjectActivityInterfaceName,
            annotatedActivityType,
            injectableAnnotationComponent!! //Either user had a component or we made one
        )
    }

    private fun componentAnvilScope(
        elements: Elements,
        injectableAnnotation: ClassName
    ): TypeMirror? {
        return elements
            .getTypeElement(injectableAnnotation.canonicalName)
            .getAnnotationClassValue<MergeComponent> { scope }
    }

    private fun injectableAnnotation(annotatedActivityTypeElement: TypeElement): ClassName? {
        return if (annotatedActivityTypeElement.getAnnotation(Injectable::class.java) != null)
            annotatedActivityTypeElement
                .getAnnotationClassValue<Injectable> { COMPONENT }
                .asTypeName() as ClassName?
        else null
    }

    private fun daggerInjectableAnnotation(annotatedActivityTypeElement: TypeElement): ClassName? {
        return if (annotatedActivityTypeElement.getAnnotation(DaggerInjectable::class.java) != null)
            annotatedActivityTypeElement
                .getAnnotationClassValue<DaggerInjectable> { dependency }
                .asTypeName() as ClassName?
        else null
    }

    private fun generateComponent(
        pack: String,
        annotatedActivityType: TypeMirror,
        dependencyClassname: ClassName
    ): String {
        val activityTypeName = annotatedActivityType.asTypeName() as ClassName
        val anvilScope = activityTypeName.peerClass("A${activityTypeName.simpleName}Scope")
        FileSpec.builder(pack, activityTypeName.simpleName + "GeneratedComponent")
            .addType(daggerScope(activityTypeName))
            .addType(TypeSpec.classBuilder(anvilScope).build())
            .addType(featureComponent(activityTypeName, dependencyClassname))
            .build().writeTo(filer)
        return activityTypeName.canonicalName + "GeneratedComponent"
    }

    private fun writeInterfaceFile(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror,
        className: ClassName?
    ) {
        val interfaceFileSpec = generateInjectorInterfaceFileSpec(
            pack, interfaceName, "activity", activityType, className
        )
        interfaceFileSpec.writeTo(filer)
    }

    private fun writeExtensionFunctionFile(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror,
        componentClass: ClassName
    ) {
        val extensionFunctionFileSpec = generateExtensionFunctionFileSpec(
            pack, interfaceName, activityType, componentClass
        )

        extensionFunctionFileSpec.writeTo(filer)
    }

    private fun generateExtensionFunctionFileSpec(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror,
        componentClass: ClassName,
    ): FileSpec {
        val extensionFunctionSpec = generateInjectExtensionFunctionForActivity(
            interfaceName, activityType
        )

        val fileBuilder = FileSpec.builder(pack, interfaceName)
        val activityTypeName = activityType.asTypeName() as ClassName

        val injectorClass = activityTypeName.peerClass("${activityTypeName.simpleName}Injector")
        val injectorFactory =
            ClassName("com.dropbox.kaiken.runtime", "InjectorFactory")
                .parameterizedBy(
                    injectorClass
                )

        val anonymousClass = TypeSpec
            .anonymousClassBuilder()
            .addSuperinterface(injectorFactory)
            .addFunction(
                FunSpec.builder("createInjector")
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement(
                        "return Dagger${componentClass.simpleName}.factory().create(resolveDependencyProvider()) as %T",
                        injectorClass
                    )
                    .build()
            )
            .build()

        return fileBuilder.addComment(GENERATED_BY_TOP_COMMENT)
            .addFunction(extensionFunctionSpec)
            .addFunction(
                FunSpec.builder("injector")
                    .receiver(Class.forName("com.dropbox.kaiken.scoping.DependencyProviderResolver"))
                    .returns(injectorFactory)
                    .addStatement("return %L", anonymousClass).build()
            )

            .build()
    }

    private fun daggerScope(activityTypeName: ClassName): TypeSpec {
        val daggerScope = activityTypeName.peerClass("${activityTypeName.simpleName}Scope")
        return TypeSpec.annotationBuilder(daggerScope)
            .addAnnotation(ClassName("javax.inject", "Scope"))
            .build()
    }

    private fun featureComponent(
        activityTypeName: ClassName,
        dependencyClassname: ClassName
    ): TypeSpec {
        val daggerComponent: ClassName =
            activityTypeName.peerClass("${activityTypeName.simpleName}Component")
        val aAnvilScope = activityTypeName.peerClass("A${activityTypeName.simpleName}Scope")
        val componentType =
            if (anvilOnPath()) ClassName("com.squareup.anvil.annotations", "MergeComponent")
            else ClassName("dagger", "Component")

        val factory =
            TypeSpec.interfaceBuilder(daggerComponent.peerClass( "Factory"))
                .addAnnotation(
                    AnnotationSpec.builder(ClassName("dagger", "Component", "Factory")).build()
                )
                .addFunction(
                    FunSpec.builder("create")
                        .addModifiers(KModifier.ABSTRACT)
                        .addParameter(dependencyClassname.simpleName, dependencyClassname)
                        .returns(daggerComponent)
                        .build()
                ).build()
        return TypeSpec.interfaceBuilder(daggerComponent)
            .addType(factory)
            .addAnnotation(activityTypeName.peerClass("${activityTypeName.simpleName}Scope"))
            .addAnnotation(
                AnnotationSpec.builder(componentType)
                    .addMember("scope = %T::class", aAnvilScope)
                    .addMember("dependencies = [%T::class]", dependencyClassname)
                    .build()
            )
            .build()
    }
}
// @MergeComponent(scope = ALaunchScope::class, dependencies = [LaunchDependencies::class])
// @LaunchScope
// interface LaunchComponent  {
//     @Component.Factory
//     interface Factory {
//         fun create(dependencies: LaunchDependencies): LaunchComponent
//     }
// }

internal fun resolveInterfaceName(
    annotatedActivity: InjectableAnnotatedActivity
): String = resolveInjectorInterfaceName(annotatedActivity.annotatedActivityElement)

internal fun generateInjectExtensionFunctionForActivity(
    interfaceName: String,
    activityType: TypeMirror
): FunSpec {
    return FunSpec.builder("inject")
        .receiver(activityType.asTypeName())
        .addStatement("val activityInjector: $interfaceName = this.locateInjector()")
        .addStatement("activityInjector.inject(this)")
        .build()
}

fun anvilOnPath(): Boolean {
    try {
        Class.forName("com.squareup.anvil.annotations.ContributesTo")
    } catch (e: ClassNotFoundException) {
        return false
    }
    return true
}

inline fun <reified T : Annotation> Element.getAnnotationClassValue(f: T.() -> KClass<*>) =
    try {
        getAnnotation(T::class.java).f()
        throw Exception("Expected to get a MirroredTypeException")
    } catch (e: MirroredTypeException) {
        e.typeMirror
    }
