package com.dropbox.kaiken.processor

import com.dropbox.kaiken.Injector
import com.dropbox.kaiken.processor.internal.GENERATED_BY_TOP_COMMENT
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterSpec
import com.squareup.javapoet.TypeName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import javax.annotation.processing.Filer
import javax.lang.model.element.Modifier
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements

/**
 * Generates a `Injector` interface definition and an `inject` function for the given annotated
 * activity.
 *
 * Example:
 *
 * ```
 * @InjectableActivity
 * public class MyActivity : AppCompatActivity() {
 *     ...
 * }
 * ```
 *
 * will generate:
 *
 * ```
 * interface MyActivityInjector {
 *    void inject(activity: MyActivity)
 * }
 *
 * fun MyActivity.inject() {
 *     val injector: MyActivityInjector = this.locateInjector()
 *     injector.inject(this)
 * }
 * ```
 *
 * Note that the interface definition is written in Java this is because of an issue with Dagger
 * (https://github.com/google/dagger/issues/665). Dagger is not auto-generating code for
 * autogenerated interfaces written in Kotlin, so leave the interface definition in Java for now.
 */
internal class InjectableActivityWriter(
    private val filer: Filer,
    private val elementUtils: Elements
) {

    fun write(annotatedActivity: InjectableAnnotatedActivity) {
        val annotatedActivityTypeElement = annotatedActivity.annotatedActivityElement
        val canInjectActivityInterfaceName = resolveInterfaceName(annotatedActivity)
        val pack = elementUtils.getPackageOf(annotatedActivityTypeElement).toString()
        val annotatedActivityType = annotatedActivityTypeElement.asType()

        writeInterfaceFile(pack, canInjectActivityInterfaceName, annotatedActivityType)
        writeExtensionFunctionFile(pack, canInjectActivityInterfaceName, annotatedActivityType)
    }

    private fun writeInterfaceFile(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror
    ) {
        val interfaceFileSpec = generateInjectorInterfaceFileSpec(
            pack, interfaceName, "activity", TypeName.get(activityType)
        )
        interfaceFileSpec.writeTo(filer)
    }

    private fun writeExtensionFunctionFile(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror
    ) {
        val extensionFunctionFileSpec = generateExtensionFunctionFileSpec(
            pack, interfaceName, activityType.asTypeName()
        )

        extensionFunctionFileSpec.writeTo(filer)
    }

    private fun resolveInterfaceName(
            annotatedActivity: InjectableAnnotatedActivity
    ): String = resolveInjectorInterfaceName(annotatedActivity.annotatedActivityElement)
}

private fun generateInjectExtensionFunctionForActivity(
        interfaceName: String,
        typeName: com.squareup.kotlinpoet.TypeName
): FunSpec {
    return FunSpec.builder("inject")
            .receiver(typeName)
            .addStatement("val activityInjector: $interfaceName = this.locateInjector()")
            .addStatement("activityInjector.inject(this)")
            .build()
}

private fun generateInjectInterfaceForActivity(
        interfaceName: String,
        typeName: com.squareup.kotlinpoet.TypeName
): TypeSpec {
    val interfaceBuilder = TypeSpec.interfaceBuilder(interfaceName)
    return interfaceBuilder
            .addSuperinterface(typeName)
            .addModifiers(KModifier.PUBLIC)
            .addFunction(
                    FunSpec.builder("inject")
                            .addModifiers(
                                KModifier.PUBLIC)
                            .addParameter(
                                    com.squareup.kotlinpoet.ParameterSpec(
                                            "activity",
                                            typeName
                                    )
                            )
                            .build()
                    ).build()
}

internal fun generateExtensionFunctionFileSpec(
        pack: String,
        interfaceName: String,
        typeName: com.squareup.kotlinpoet.TypeName
): FileSpec {
    val extensionFunctionSpec = generateInjectExtensionFunctionForActivity(
            interfaceName, typeName
    )
    val interfaceTypeSpec = generateInjectInterfaceForActivity(
            interfaceName, typeName
    )

    val fileBuilder = FileSpec.builder(pack, interfaceName)

    return fileBuilder.addComment(GENERATED_BY_TOP_COMMENT)
            .addFunction(extensionFunctionSpec)
            .addType(interfaceTypeSpec)
            .build()
}
