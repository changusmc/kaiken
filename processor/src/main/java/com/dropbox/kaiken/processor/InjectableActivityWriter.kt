package com.dropbox.kaiken.processor

import com.dropbox.kaiken.processor.internal.GENERATED_BY_TOP_COMMENT
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import javax.annotation.processing.Filer
import javax.annotation.processing.Messager
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements

/**
 * Generates a `Injector` interface definition and an `inject` function for the given annotated
 * activity.
 *
 * Example:
 *
 * ```
 * @InjectableActivity
 * public class MyActivity : AppCompatActivity() {
 *     ...
 * }
 * ```
 *
 * will generate:
 *
 * ```
 * interface MyActivityInjector {
 *    void inject(activity: MyActivity)
 * }
 *
 * fun MyActivity.inject() {
 *     val injector: MyActivityInjector = this.locateInjector()
 *     injector.inject(this)
 * }
 * ```
 *
 * Note that the interface definition is written in Java this is because of an issue with Dagger
 * (https://github.com/google/dagger/issues/665). Dagger is not auto-generating code for
 * autogenerated interfaces written in Kotlin, so leave the interface definition in Java for now.
 */
internal class InjectableActivityWriter(
        private val filer: Filer,
        private val elementUtils: Elements,
        messager: Messager
) {
    fun write(
            annotatedActivity: InjectableAnnotatedActivity,
            elements: Elements
    ) {

        val annotatedActivityTypeElement = annotatedActivity.annotatedActivityElement
        val canInjectActivityInterfaceName = resolveInterfaceName(annotatedActivity)
        val pack = elementUtils.getPackageOf(annotatedActivityTypeElement).toString()
        val annotatedActivityType = annotatedActivityTypeElement.asType()

        val dependendecies = dependenciesValue(annotatedActivityTypeElement)

        val (injectableAnnotationComponent, anvilScope: ClassName?) = generateAnvilParts(annotatedActivityTypeElement, elements, annotatedActivityType, pack, filer, dependendecies)

        writeExtensionFunctionFile(
                pack,
                canInjectActivityInterfaceName,
                annotatedActivityType,
                injectableAnnotationComponent!! //Either user had a component or we made one
        )

        // elements.
        writeInterfaceFile(
                pack,
                canInjectActivityInterfaceName,
                annotatedActivityType,
                anvilScope
        )


    }


    private fun writeInterfaceFile(
            pack: String,
            interfaceName: String,
            activityType: TypeMirror,
            anvilScope: ClassName?
    ) {
        val interfaceFileSpec = generateInjectorInterfaceFileSpec(
                pack, interfaceName, "activity", activityType, anvilScope
        )
        interfaceFileSpec.writeTo(filer)
    }

    private fun writeExtensionFunctionFile(
            pack: String,
            interfaceName: String,
            activityType: TypeMirror,
            componentClass: ClassName
    ) {
        val extensionFunctionFileSpec = generateExtensionFunctionFileSpec(
                pack, interfaceName, activityType, componentClass
        )

        extensionFunctionFileSpec.writeTo(filer)
    }

    private fun generateExtensionFunctionFileSpec(
            pack: String,
            interfaceName: String,
            activityType: TypeMirror,
            componentClass: ClassName,
    ): FileSpec {
        val extensionFunctionSpec = generateInjectExtensionFunctionForActivity(
                interfaceName, activityType
        )

        val fileBuilder = FileSpec.builder(pack, interfaceName)
        val activityTypeName = activityType.asTypeName() as ClassName


        val extensionFunctions = fileBuilder.addComment(GENERATED_BY_TOP_COMMENT)
                .addFunction(extensionFunctionSpec)
        return extensionFunctions


                .build()
    }



    private fun resolveInterfaceName(
            annotatedActivity: InjectableAnnotatedActivity
    ): String = resolveInjectorInterfaceName(annotatedActivity.annotatedActivityElement)

    private fun generateInjectExtensionFunctionForActivity(
            interfaceName: String,
            activityType: TypeMirror
    ): FunSpec {
        return FunSpec.builder("inject")
                .receiver(activityType.asTypeName())
                .addStatement("val activityInjector: $interfaceName = this.locateInjector()")
                .addStatement("activityInjector.inject(this)")
                .build()
    }
}

