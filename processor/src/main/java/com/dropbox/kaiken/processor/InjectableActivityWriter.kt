package com.dropbox.kaiken.processor

import com.dropbox.kaiken.annotation.Injectable
import com.dropbox.kaiken.processor.internal.GENERATED_BY_TOP_COMMENT
import com.squareup.anvil.annotations.MergeComponent
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import javax.annotation.processing.Filer
import javax.lang.model.element.Element
import javax.lang.model.type.MirroredTypeException
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import kotlin.reflect.KClass

/**
 * Generates a `Injector` interface definition and an `inject` function for the given annotated
 * activity.
 *
 * Example:
 *
 * ```
 * @InjectableActivity
 * public class MyActivity : AppCompatActivity() {
 *     ...
 * }
 * ```
 *
 * will generate:
 *
 * ```
 * interface MyActivityInjector {
 *    void inject(activity: MyActivity)
 * }
 *
 * fun MyActivity.inject() {
 *     val injector: MyActivityInjector = this.locateInjector()
 *     injector.inject(this)
 * }
 * ```
 *
 * Note that the interface definition is written in Java this is because of an issue with Dagger
 * (https://github.com/google/dagger/issues/665). Dagger is not auto-generating code for
 * autogenerated interfaces written in Kotlin, so leave the interface definition in Java for now.
 */
internal class InjectableActivityWriter(
    private val filer: Filer,
    private val elementUtils: Elements
) {

    fun write(
        annotatedActivity: InjectableAnnotatedActivity,
        elements: Elements
    ) {
        val annotatedActivityTypeElement = annotatedActivity.annotatedActivityElement
        val canInjectActivityInterfaceName = resolveInterfaceName(annotatedActivity)
        val pack = elementUtils.getPackageOf(annotatedActivityTypeElement).toString()
        val annotatedActivityType = annotatedActivityTypeElement.asType()
        val annotationClassValue = annotatedActivityTypeElement
                .getAnnotationClassValue<Injectable> { COMPONENT }
                .asTypeName() as ClassName

        // elements.
         val scope =
            elements
                .getTypeElement(annotationClassValue.canonicalName)
                .getAnnotationClassValue<MergeComponent> {scope  }
         val scopeClassName=scope.asTypeName() as ClassName

        writeInterfaceFile(pack, canInjectActivityInterfaceName, annotatedActivityType, scopeClassName)
        writeExtensionFunctionFile(pack, canInjectActivityInterfaceName, annotatedActivityType,annotationClassValue)
    }

    inline fun <reified T : Annotation> Element.getAnnotationClassValue(f: T.() -> KClass<*>) = try {
        getAnnotation(T::class.java).f()
        throw Exception("Expected to get a MirroredTypeException")
    } catch (e: MirroredTypeException) {
        e.typeMirror
    }

    private fun writeInterfaceFile(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror,
        className: ClassName
    ) {
        val interfaceFileSpec = generateInjectorInterfaceFileSpec(
            pack, interfaceName, "activity", activityType, className
        )
        interfaceFileSpec.writeTo(filer)
    }

    private fun writeExtensionFunctionFile(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror,
        componentClass: ClassName
    ) {
        val extensionFunctionFileSpec = generateExtensionFunctionFileSpec(
            pack, interfaceName, activityType,componentClass
        )

        extensionFunctionFileSpec.writeTo(filer)
    }

    private fun generateExtensionFunctionFileSpec(
        pack: String,
        interfaceName: String,
        activityType: TypeMirror,
        componentClass: ClassName
    ): FileSpec {
        val extensionFunctionSpec = generateInjectExtensionFunctionForActivity(
            interfaceName, activityType
        )

        val fileBuilder = FileSpec.builder(pack, interfaceName)
        val activityTypeName = activityType.asTypeName() as ClassName

        val injectorClass = activityTypeName.peerClass("${activityTypeName.simpleName}Injector")
        val injectorFactory =
            Class.forName("com.dropbox.kaiken.runtime.InjectorFactory").asClassName()
                .parameterizedBy(
                    injectorClass
                )

        val anonymousClass = TypeSpec
            .anonymousClassBuilder()
            .addSuperinterface(injectorFactory)
            .addFunction(
                FunSpec.builder("createInjector")
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement(
                        "return Dagger${componentClass.simpleName}.factory().create(resolveDependencyProvider()) as %T",
                        injectorClass
                    )
                    .build()
            )
            .build()


        return fileBuilder.addComment(GENERATED_BY_TOP_COMMENT)
            .addFunction(extensionFunctionSpec)
            .addFunction(
                FunSpec.builder("injector")
                    .receiver(Class.forName("com.dropbox.kaiken.scoping.DependencyProviderResolver"))
                    .returns(injectorFactory)
                    .addStatement("return %L", anonymousClass).build()
            )
            .build()
    }
}
// internal fun DependencyProviderResolver.injector() =
//     object : InjectorFactory<LaunchActivityInjector> {
//         override fun createInjector() = ...
//     }

internal fun resolveInterfaceName(
    annotatedActivity: InjectableAnnotatedActivity
): String = resolveInjectorInterfaceName(annotatedActivity.annotatedActivityElement)

internal fun generateInjectExtensionFunctionForActivity(
    interfaceName: String,
    activityType: TypeMirror
): FunSpec {
    return FunSpec.builder("inject")
        .receiver(activityType.asTypeName())
        .addStatement("val activityInjector: $interfaceName = this.locateInjector()")
        .addStatement("activityInjector.inject(this)")
        .build()
}
